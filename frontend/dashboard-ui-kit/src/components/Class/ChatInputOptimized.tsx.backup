import React, { useRef, memo, useCallback, useImperativeHandle, forwardRef, useState, useEffect } from 'react';
import { ArrowUp } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { TextCloudPopup } from './TextCloudPopup';
import { CommandSuggestions } from './CommandSuggestions';
import { FileSuggestions } from './FileSuggestions';
import { ClassSuggestions } from './ClassSuggestions';
import { IndicatorsList, IndicatorItem } from './IndicatorsList';
import { useTheme } from '../../contexts/ThemeContext';
import { useAuth } from '../../contexts/AuthContext';
import { Course } from '../../types';

interface ChatInputProps {
  onSubmit: (message: string) => void;
  isAiLoading: boolean;
  selectedTextForChat?: string;
  onClearSelectedText?: () => void;
  isPdfPreviewOpen?: boolean;
  currentPdfPage?: number;
  onClearChat?: () => void;
  files?: Array<{ id: string; name: string; type: string }>;
  indicatorItems?: IndicatorItem[];
  onIndicatorItemsChange?: (items: IndicatorItem[]) => void;
  value?: string;
  onValueChange?: (value: string) => void;
  courses?: Course[];
}

export interface ChatInputHandle {
  focus: () => void;
  clear: () => void;
}

interface Command {
  name: string;
  description: string;
  action: () => void;
}

interface File {
  id: string;
  name: string;
  type: string;
}

export const ChatInputOptimized = memo(forwardRef<ChatInputHandle, ChatInputProps>(({
  onSubmit,
  isAiLoading,
  selectedTextForChat,
  onClearSelectedText,
  isPdfPreviewOpen,
  currentPdfPage,
  onClearChat,
  files = [],
  indicatorItems: externalIndicatorItems,
  onIndicatorItemsChange,
  value: externalValue,
  onValueChange,
  courses = [],
}, ref) => {
  const { isDark, toggleTheme } = useTheme();
  const { logout } = useAuth();
  const navigate = useNavigate();
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const lastHeightRef = useRef<number>(0);
  // Use external value if provided, otherwise manage locally
  const [localValue, setLocalValue] = useState('');
  const internalValue = externalValue ?? localValue;
  const setInternalValue = onValueChange ?? setLocalValue;
  const [showCommands, setShowCommands] = useState(false);
  const [selectedCommandIndex, setSelectedCommandIndex] = useState(0);
  const [commandFilter, setCommandFilter] = useState('');
  const [showFiles, setShowFiles] = useState(false);
  const [selectedFileIndex, setSelectedFileIndex] = useState(0);
  const [fileFilter, setFileFilter] = useState('');
  const [showClassSuggestions, setShowClassSuggestions] = useState(false);
  const [selectedClassIndex, setSelectedClassIndex] = useState(0);
  const [classFilter, setClassFilter] = useState('');
  
  // Use external indicator items if provided, otherwise manage locally
  const [localIndicatorItems, setLocalIndicatorItems] = useState<IndicatorItem[]>([]);
  const indicatorItems = externalIndicatorItems ?? localIndicatorItems;
  const setIndicatorItems = onIndicatorItemsChange ?? setLocalIndicatorItems;

  // Reset height when clearing
  const resetHeight = useCallback(() => {
    if (textareaRef.current) {
      const minHeight = 60;
      textareaRef.current.style.height = `${minHeight}px`;
      textareaRef.current.style.overflowY = 'hidden';
      lastHeightRef.current = minHeight;
    }
  }, []);

  // Available commands
  const allCommands: Command[] = [
    {
      name: '/clear',
      description: 'Clear the chat history',
      action: () => {
        if (onClearChat) {
          onClearChat();
          setInternalValue('');
          setShowCommands(false);
          if (textareaRef.current) {
            textareaRef.current.value = '';
            resetHeight();
          }
        }
      }
    },
    {
      name: '/theme',
      description: 'Change theme (usage: /theme light or /theme dark)',
      action: () => {
        // This will be handled in the command execution logic
        setShowCommands(false);
      }
    },
    {
      name: '/logout',
      description: 'Log out of your account',
      action: async () => {
        await logout();
        navigate('/login');
      }
    },
    {
      name: '/cd',
      description: 'Change to a different class (usage: /cd [class name])',
      action: () => {
        // This will be handled in the command execution logic
        setShowCommands(false);
      }
    }
  ];

  // Filter commands based on input
  const filteredCommands = allCommands.filter(cmd => 
    cmd.name.toLowerCase().startsWith(commandFilter.toLowerCase())
  );

  // Filter files based on input
  const filteredFiles = files.filter(file => 
    file.name.toLowerCase().includes(fileFilter.toLowerCase())
  );
  
  // Filter courses based on input
  const filteredCourses = courses.filter(course => 
    course.name.toLowerCase().includes(classFilter.toLowerCase()) ||
    course.code.toLowerCase().includes(classFilter.toLowerCase())
  );

  // Handle command selection
  const selectCommand = useCallback((command: Command) => {
    if (command.name === '/theme') {
      // Don't execute immediately, let user type the parameter
      setInternalValue('/theme ');
      setShowCommands(false);
      setCommandFilter('');
      setSelectedCommandIndex(0);
      if (textareaRef.current) {
        textareaRef.current.value = '/theme ';
        textareaRef.current.focus();
      }
    } else if (command.name === '/cd') {
      // Don't execute immediately, show class suggestions
      setInternalValue('/cd ');
      setShowCommands(false);
      setCommandFilter('');
      setSelectedCommandIndex(0);
      setShowClassSuggestions(true);
      setClassFilter('');
      if (textareaRef.current) {
        textareaRef.current.value = '/cd ';
        textareaRef.current.focus();
      }
    } else {
      command.action();
      setShowCommands(false);
      setCommandFilter('');
      setSelectedCommandIndex(0);
    }
  }, [setInternalValue]);

  // Handle PDF preview state changes
  useEffect(() => {
    // Remove any existing current-page indicator
    const filtered = indicatorItems.filter(item => item.type !== 'current-page');
    
    if (isPdfPreviewOpen) {
      // Add current page indicator at the beginning
      const newItems = [{
        id: 'current-page',
        type: 'current-page' as const,
        name: 'Current page',
        removable: false
      }, ...filtered];
      setIndicatorItems(newItems);
    } else {
      setIndicatorItems(filtered);
    }
  }, [isPdfPreviewOpen, setIndicatorItems]);

  // Define adjustHeight first to avoid reference errors
  const adjustHeight = useCallback(() => {
    if (!textareaRef.current) return;
    
    const textarea = textareaRef.current;
    const maxHeight = 220;
    const minHeight = 60;
    
    // Reset height to auto to get the correct scrollHeight
    textarea.style.height = 'auto';
    
    // Get the scroll height
    const scrollHeight = textarea.scrollHeight;
    
    // Set the appropriate height
    if (scrollHeight > maxHeight) {
      textarea.style.height = `${maxHeight}px`;
      textarea.style.overflowY = 'auto';
    } else if (scrollHeight > minHeight) {
      textarea.style.height = `${scrollHeight}px`;
      textarea.style.overflowY = 'hidden';
    } else {
      textarea.style.height = `${minHeight}px`;
      textarea.style.overflowY = 'hidden';
    }
    
    lastHeightRef.current = scrollHeight;
  }, []);

  const handleInput = useCallback(() => {
    // Use RAF for smooth updates
    requestAnimationFrame(adjustHeight);
  }, [adjustHeight]);

  // Handle class selection
  const selectClass = useCallback((course: Course) => {
    // Navigate directly instead of simulating enter key
    navigate(`/class/${course.id}`);
    setInternalValue('');
    setShowClassSuggestions(false);
    setClassFilter('');
    setSelectedClassIndex(0);
    if (textareaRef.current) {
      textareaRef.current.value = '';
      resetHeight();
    }
  }, [navigate, resetHeight]);

  // Handle file selection
  const selectFile = useCallback((file: File) => {
    // Add to indicator items if not already there
    const currentItems = indicatorItems;
    
    if (!currentItems.some(item => item.id === file.id)) {
      const newItem = {
        id: file.id,
        type: 'document' as const,
        name: file.name,
        removable: true
      };
      const newItems = [...currentItems, newItem];
      setIndicatorItems(newItems);
    }
    
    // Clear the @ mention from input
    const currentValue = internalValue;
    const lastAtIndex = currentValue.lastIndexOf('@');
    const newValue = currentValue.substring(0, lastAtIndex);
    
    setInternalValue(newValue);
    if (textareaRef.current) {
      textareaRef.current.value = newValue;
      // Trigger height adjustment
      requestAnimationFrame(() => {
        handleInput();
      });
    }
    setShowFiles(false);
    setFileFilter('');
    setSelectedFileIndex(0);
  }, [internalValue, handleInput, indicatorItems, setIndicatorItems]);

  // Handle removing indicator item
  const removeIndicatorItem = useCallback((itemId: string) => {
    const filtered = indicatorItems.filter(item => item.id !== itemId);
    setIndicatorItems(filtered);
  }, [indicatorItems, setIndicatorItems]);

  // Expose methods to parent
  useImperativeHandle(ref, () => ({
    focus: () => textareaRef.current?.focus(),
    clear: () => {
      setInternalValue('');
      if (textareaRef.current) {
        textareaRef.current.value = '';
        resetHeight();
      }
    }
  }), [resetHeight]);

  const handleCloseCloud = useCallback(() => {
    onClearSelectedText?.();
  }, [onClearSelectedText]);

  // Sync textarea value with internal value
  useEffect(() => {
    if (textareaRef.current && textareaRef.current.value !== internalValue) {
      textareaRef.current.value = internalValue;
      handleInput();
    }
  }, [internalValue, handleInput]);

  // Handle text change
  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const value = e.target.value;
    setInternalValue(value);

    // Get the current cursor position
    const cursorPosition = e.target.selectionStart;
    const textBeforeCursor = value.substring(0, cursorPosition);
    
    // Check for @ mentions
    const lastAtIndex = textBeforeCursor.lastIndexOf('@');
    const lastSpaceIndex = textBeforeCursor.lastIndexOf(' ');
    const lastNewlineIndex = textBeforeCursor.lastIndexOf('\n');
    const lastBreakIndex = Math.max(lastSpaceIndex, lastNewlineIndex);
    
    if (lastAtIndex > lastBreakIndex && lastAtIndex !== -1) {
      // User is typing a file mention
      const filterText = textBeforeCursor.substring(lastAtIndex + 1);
      setShowFiles(true);
      setFileFilter(filterText);
      setSelectedFileIndex(0);
      setShowCommands(false);
      setCommandFilter('');
    } else if (value.startsWith('/cd ') && value.length > 4) {
      // User is typing class name after /cd command
      const classFilterText = value.substring(4).trim();
      setShowClassSuggestions(true);
      setClassFilter(classFilterText);
      setSelectedClassIndex(0);
      setShowCommands(false);
      setShowFiles(false);
    } else if (value.startsWith('/')) {
      // Check if user is typing a command
      setShowCommands(true);
      setCommandFilter(value);
      setSelectedCommandIndex(0);
      setShowFiles(false);
      setFileFilter('');
      setShowClassSuggestions(false);
    } else {
      setShowCommands(false);
      setCommandFilter('');
      setShowFiles(false);
      setFileFilter('');
      setShowClassSuggestions(false);
    }
  }, []);

  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    // Handle file suggestions navigation
    if (showFiles && filteredFiles.length > 0) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        setSelectedFileIndex((prev) => (prev + 1) % filteredFiles.length);
        return;
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        setSelectedFileIndex((prev) => (prev - 1 + filteredFiles.length) % filteredFiles.length);
        return;
      } else if (e.key === 'Tab') {
        e.preventDefault();
        const selectedFile = filteredFiles[selectedFileIndex];
        if (selectedFile) {
          selectFile(selectedFile);
        }
        return;
      } else if (e.key === 'Enter') {
        e.preventDefault();
        const selectedFile = filteredFiles[selectedFileIndex];
        if (selectedFile) {
          selectFile(selectedFile);
        }
        return;
      } else if (e.key === 'Escape') {
        e.preventDefault();
        setShowFiles(false);
        setFileFilter('');
        return;
      }
    }
    
    // Handle command suggestions navigation
    if (showCommands && filteredCommands.length > 0) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        setSelectedCommandIndex((prev) => (prev + 1) % filteredCommands.length);
        return;
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        setSelectedCommandIndex((prev) => (prev - 1 + filteredCommands.length) % filteredCommands.length);
        return;
      } else if (e.key === 'Tab') {
        e.preventDefault();
        const selectedCommand = filteredCommands[selectedCommandIndex];
        if (selectedCommand) {
          setInternalValue(selectedCommand.name);
          if (textareaRef.current) {
            textareaRef.current.value = selectedCommand.name;
          }
        }
        return;
      } else if (e.key === 'Enter') {
        e.preventDefault();
        const selectedCommand = filteredCommands[selectedCommandIndex];
        if (selectedCommand) {
          selectCommand(selectedCommand);
        }
        return;
      } else if (e.key === 'Escape') {
        e.preventDefault();
        setShowCommands(false);
        setCommandFilter('');
        return;
      }
    }
    
    // Handle class suggestions navigation
    if (showClassSuggestions && filteredCourses.length > 0) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        setSelectedClassIndex((prev) => (prev + 1) % filteredCourses.length);
        return;
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        setSelectedClassIndex((prev) => (prev - 1 + filteredCourses.length) % filteredCourses.length);
        return;
      } else if (e.key === 'Tab' || e.key === 'Enter') {
        e.preventDefault();
        const selectedCourse = filteredCourses[selectedClassIndex];
        if (selectedCourse) {
          selectClass(selectedCourse);
        }
        return;
      } else if (e.key === 'Escape') {
        e.preventDefault();
        setShowClassSuggestions(false);
        setClassFilter('');
        return;
      }
    }

    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      e.stopPropagation();
      
      // Check if it's a command
      const trimmedValue = internalValue.trim();
      
      // Handle /theme command with parameters
      if (trimmedValue.startsWith('/theme ')) {
        const param = trimmedValue.substring(7).trim().toLowerCase();
        if (param === 'light' && isDark) {
          toggleTheme();
        } else if (param === 'dark' && !isDark) {
          toggleTheme();
        }
        setInternalValue('');
        if (textareaRef.current) {
          textareaRef.current.value = '';
          resetHeight();
        }
        return;
      }
      
      // Handle /cd command with parameters
      if (trimmedValue.startsWith('/cd ')) {
        const className = trimmedValue.substring(4).trim();
        const matchedCourse = courses.find(course => 
          course.name.toLowerCase() === className.toLowerCase() ||
          course.code.toLowerCase() === className.toLowerCase()
        );
        if (matchedCourse) {
          navigate(`/class/${matchedCourse.id}`);
        }
        setInternalValue('');
        if (textareaRef.current) {
          textareaRef.current.value = '';
          resetHeight();
        }
        return;
      }
      
      const matchedCommand = allCommands.find(cmd => cmd.name === trimmedValue);
      if (matchedCommand) {
        matchedCommand.action();
        return;
      }
      
      // Only submit if AI is not loading and not a command
      if (!isAiLoading && (internalValue.trim() || selectedTextForChat?.trim()) && !internalValue.startsWith('/')) {
        onSubmit(internalValue);
        setInternalValue('');
        if (textareaRef.current) {
          textareaRef.current.value = '';
          resetHeight();
        }
      }
    }
  }, [internalValue, selectedTextForChat, onSubmit, resetHeight, isAiLoading, showCommands, filteredCommands, selectedCommandIndex, selectCommand, allCommands, showFiles, filteredFiles, selectedFileIndex, selectFile, isDark, toggleTheme, showClassSuggestions, filteredCourses, selectedClassIndex, selectClass, courses, navigate]);

  const handleFormSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    e.stopPropagation();
    
    // Check if it's a command
    const trimmedValue = internalValue.trim();
    
    // Handle /theme command with parameters
    if (trimmedValue.startsWith('/theme ')) {
      const param = trimmedValue.substring(7).trim().toLowerCase();
      if (param === 'light' && isDark) {
        toggleTheme();
      } else if (param === 'dark' && !isDark) {
        toggleTheme();
      }
      setInternalValue('');
      if (textareaRef.current) {
        textareaRef.current.value = '';
        resetHeight();
      }
      return;
    }
    
    // Handle /cd command with parameters
    if (trimmedValue.startsWith('/cd ')) {
      const className = trimmedValue.substring(4).trim();
      const matchedCourse = courses.find(course => 
        course.name.toLowerCase() === className.toLowerCase() ||
        course.code.toLowerCase() === className.toLowerCase()
      );
      if (matchedCourse) {
        navigate(`/classes/${matchedCourse.id}`);
      }
      setInternalValue('');
      if (textareaRef.current) {
        textareaRef.current.value = '';
        resetHeight();
      }
      return;
    }
    
    const matchedCommand = allCommands.find(cmd => cmd.name === trimmedValue);
    if (matchedCommand) {
      matchedCommand.action();
      return;
    }
    
    // Only submit if AI is not loading and not a command
    if (!isAiLoading && (internalValue.trim() || selectedTextForChat?.trim()) && !internalValue.startsWith('/')) {
      onSubmit(internalValue);
      setInternalValue('');
      if (textareaRef.current) {
        textareaRef.current.value = '';
        resetHeight();
      }
    }
  }, [internalValue, selectedTextForChat, onSubmit, resetHeight, isAiLoading, allCommands, isDark, toggleTheme, courses, navigate]);

  return (
    <div className="pb-4 bg-transparent -mt-16 relative z-50">
      <div className="max-w-4xl mx-auto px-12 py-1">
        <form onSubmit={handleFormSubmit} className="w-full bg-transparent">
          <div className="relative">
            <div className="relative bg-white dark:bg-neutral-700 border border-gray-300 dark:border-neutral-600 rounded-xl focus-within:ring-2 focus-within:ring-orange-500 focus-within:border-orange-500">
              {showCommands && (
                <CommandSuggestions
                  commands={filteredCommands}
                  selectedIndex={selectedCommandIndex}
                  onSelectCommand={selectCommand}
                />
              )}
              {showFiles && (
                <FileSuggestions
                  files={filteredFiles}
                  selectedIndex={selectedFileIndex}
                  onSelectFile={selectFile}
                />
              )}
              {showClassSuggestions && (
                <ClassSuggestions
                  courses={filteredCourses}
                  selectedIndex={selectedClassIndex}
                  onSelectClass={selectClass}
                />
              )}
              {selectedTextForChat && (
                <div className="pt-1.5 pl-1.5 pr-1.5">
                  <TextCloudPopup
                    text={selectedTextForChat}
                    isVisible={true}
                    onClose={handleCloseCloud}
                  />
                </div>
              )}
              
              {indicatorItems.length > 0 && (
                <div className="px-1.5 pt-1.5">
                  <IndicatorsList 
                    items={indicatorItems} 
                    onRemoveItem={removeIndicatorItem}
                  />
                </div>
              )}
              
              <textarea
                ref={textareaRef}
                value={internalValue}
                onChange={handleTextChange}
                onInput={handleInput}
                onKeyDown={handleKeyDown}
                placeholder="Ask a question about your documents..."
                className="w-full px-1.5 border-0 focus:outline-none bg-transparent text-gray-900 dark:text-white resize-none text-base placeholder:text-base py-1.5 min-h-[60px] max-h-[220px]"
                rows={2}
                style={{
                  minHeight: '60px',
                  maxHeight: '220px',
                  height: '60px'
                }}
                disabled={false}
              />
              
              <div className="pr-1.5 pb-1.5 flex justify-end items-center">
                <button
                  type="submit"
                  disabled={isAiLoading || (!internalValue.trim() && !selectedTextForChat?.trim())}
                  className={`p-2 text-white rounded-md transition-all duration-200 disabled:cursor-not-allowed ${
                    isAiLoading || (!internalValue.trim() && !selectedTextForChat?.trim())
                      ? 'bg-[#F97316]/40 hover:bg-[#F97316]/40'
                      : 'bg-[#F97316] hover:bg-[#F97316]/90 active:bg-[#F97316]/80'
                  }`}
                >
                  <ArrowUp className="w-4 h-4" />
                </button>
              </div>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
}));

ChatInputOptimized.displayName = 'ChatInputOptimized';